Using dependency injection increases modularity, testability, maintainability, and improves the design of your application in general. It's even possible to use it for [console](https://andrewlock.net/using-dependency-injection-in-a-net-core-console-application/) apps. Use DI whenever possible.

## Standard usage

The Delivery SDK offers several methods that extend the `IServiceCollection` interface. This service enables you to register almost any IoC container available for .NET (including Autofac, Ninject, Castle Windsor, or Unity). 

The following sample shows registration to the [standard .NET Core container](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection) and [ASP.NET Core Configuration API](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration).

First, you need to create or extend the *appsettings.json* file. The properties should match the [`DeliveryOptions`](https://github.com/kontent-ai/delivery-sdk-net/Kontent.Ai.Delivery.Abstractions/Configuration/DeliveryOptions.cs) class. Further `DeliveryOptions` explanation can be found on [Delivery options explained](../configuration/delivery-options.md).

```json
{
    "DeliveryOptions": {
        "EnvironmentId": "<EnvironmentId_Value>",
        "PreviewApiKey": "<PreviewApiKey_Value>",
        "UsePreviewApi": "true",
        "WaitForLoadingNewContent": "true",
        "DefaultRenditionPreset": "<Default_rendition_preset_codename> so for example value like default, web, mobile ..."
    }
}
```

To register the `IDeliveryClient` instance with the configuration, you can use the `AddDeliveryClient` extension method on the `IServiceCollection` interface.

```csharp
public class Startup
{
    public IConfigurationRoot Configuration { get; }

    public Startup(IConfiguration configuration)
    {
        Configuration = configuration;
    }

    public void ConfigureServices(IServiceCollection services)
    {
        services.AddSingleton<ITypeProvider, CustomTypeProvider>(); // Add an implementation of ITypeProvider generated by https://github.com/kontent-ai/model-generator-net
        services.AddDeliveryClient(Configuration);
    }
}
```

Now, you can inject a fully configured `IDeliveryClient` object into your controller:

```csharp
public class HomeController : Controller
{
    private IDeliveryClient _deliveryClient;

    public HomeController(IDeliveryClient deliveryClient)
    {
        _deliveryClient = deliveryClient;
    }
}
```

## Registering custom implementations of the underlying logic

You can register your custom implementations of the SDK interfaces (such as `IContentLinkUrlResolver`, `ITypeProvider`, `IRetryPolicyProvider`, `IDeliveryCacheManager`, etc.) through the `IServiceCollection` interface:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<IContentLinkUrlResolver, CustomContentLinkUrlResolver>();
    services.AddSingleton<IRetryPolicyProvider, CustomPolicyProvider>();
    services.AddDeliveryClient(Configuration);
}
```

or through the `DeliveryClientBuilder` class:

```csharp
IDeliveryClient deliveryClient = DeliveryClientBuilder
                .WithEnvironmentId("<YOUR_ENVIRONMENT_ID>")
                .WithContentLinkUrlResolver(CustomContentLinkUrlResolver)
                .WithRetryPolicyProvider(CustomPolicyProvider>)
                .WithTypeProvider(CustomTypeProvider)
                .Build();
```

You can also use the `DeliveryOptionsBuilder` in the `AddDeliveryClient` method.

```csharp
services.AddDeliveryClient(builder =>
    builder
        .WithEnvironmentId("<EnvironmentId_Value>")

        // Example production configuration:
        .UseProductionApi("<SecuredApiKey_Value>")
        .WithCustomEndpoint("<ProductionEndpoint_Value>")
        .WithMaxRetryAttempts(3)

        /* Example alternative preview configuration:
        .UsePreviewApi("<PreviewApiKey_Value>")
        .DisableResilienceLogic
        .WithCustomEndpoint("<PreviewEndpoint_Value>")
        */
        .Build()
);
```
## Registering logger
You can register you implementation of the [`ILoggerFactory`](https://learn.microsoft.com/en-us/dotnet/api/microsoft.extensions.logging.iloggerfactory?view=dotnet-plat-ext-7.0) through the `IServiceCollection` interface:

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton<ILoggerFactory>(LoggerFactoryImplementation);
    services.AddDeliveryClient(Configuration);
}
```

or through the `DeliveryClientBuilder` class:

```csharp
IDeliveryClient deliveryClient = DeliveryClientBuilder
                .WithEnvironmentId("<YOUR_ENVIRONMENT_ID>")
                .WithLoggerFactory(LoggerFactoryImplementation)
                .Build();
```

By default `NullLoggerFactory.Instance` implementation is used.
If you register `LoggerFactory`, SDK will have a possibility to provide warning and error messages into your logs. 
> Currently this is a new option and SDK provides just small amount of logs. For example if you use [Caching responses](../retrieving-data/caching.md) with `DistributedCacheManager` and [`FallbackToApi`](../../Kontent.Ai.Delivery.Caching/DistributedCacheResilientPolicy.cs) option is chosen for `DistributedCacheResilientPolicy` parameter of `DeliveryCacheOptions`, information message will be logged when `distributed cache` is not available.

## Registering multiple clients
In case you need to register multiple differently configured `IDeliveryClient`s, you can take advantage of [named clients](multiple-delivery-clients.md).


## HttpClientFactory

The default implementation of the `IDeliveryClient` internally uses an `HttpClient`. We recommend using `HttpClientFactory` for resolving a `HttpClient`. You can do so by adding the `IDeliveryHttpClient` to the `HttpClientFactory` pipeline.

```csharp
services.AddHttpClient<IDeliveryHttpClient, DeliveryHttpClient>();
```

Using the `HttpClientFactory` increases the [stability and performance](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/http-requests) of your application. It also allows you to set up other features on top of it, such as [Polly for Retry Logic](https://docs.microsoft.com/en-US/dotnet/architecture/microservices/implement-resilient-applications/implement-http-call-retries-exponential-backoff-polly).
